(** ExtUnix *)

(** [Not_available "func"] may be raised by [ExtUnix.All.func]
    if the wrapped C function is not available on this platform *)
exception Not_available of string

(** type of buffer used by BA submodules *)
type buffer =
    (int, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

HAVE FSYNC
external fsync : Unix.file_descr -> unit = "caml_extunix_fsync"
END

HAVE FDATASYNC
external fdatasync : Unix.file_descr -> unit = "caml_extunix_fdatasync"
END

HAVE EVENTFD
external eventfd : int -> Unix.file_descr = "caml_extunix_eventfd"
external eventfd_read : Unix.file_descr -> int64 = "caml_extunix_eventfd_read"
external eventfd_write : Unix.file_descr -> int64 -> unit = "caml_extunix_eventfd_write"
END

HAVE DIRFD
external dirfd : Unix.dir_handle -> Unix.file_descr = "caml_extunix_dirfd"
END

HAVE STATVFS
type statvfs = {
  f_bsize : int; (** file system block size *)
  f_blocks : int64; (** size of file system in blocks *)
  f_bfree : int64; (** free blocks *)
  f_bavail : int64; (** free blocks for unprivileged users *)
  f_files : int64; (** inodes *)
  f_ffree : int64; (** free inodes *)
  f_favail : int64; (** free inodes for unprivileged users *)
  f_fsid : int64; (** file system ID *)
  f_flag : int; (** mount flags *)
  f_namemax : int; (** maximum filename length *)
}
external statvfs : string -> statvfs = "caml_extunix_statvfs"
external fstatvfs : Unix.file_descr -> statvfs = "caml_extunix_fstatvfs"
END

HAVE ATFILE
(*
external at_fdcwd : unit -> Unix.file_descr

(** Pseudo file descriptor denoting current directory *)
let at_fdcwd = at_fdcwd ()
*)

type at_flag = AT_EACCESS | AT_SYMLINK_NOFOLLOW | AT_REMOVEDIR | AT_SYMLINK_FOLLOW
external openat : Unix.file_descr -> string -> Unix.open_flag list -> Unix.file_perm -> Unix.file_descr = "caml_extunix_openat"
external fstatat : Unix.file_descr -> string -> Unix.stats = "caml_extunix_fstatat"
(** Supported flags : [AT_REMOVEDIR] *)
external unlinkat : Unix.file_descr -> string -> at_flag list -> unit = "caml_extunix_unlinkat"
external renameat : Unix.file_descr -> string -> Unix.file_descr -> string -> unit = "caml_extunix_renameat"
external mkdirat : Unix.file_descr -> string -> int -> unit = "caml_extunix_mkdirat"
(** Supported flags : [AT_SYMLINK_FOLLOW] *)
external linkat : Unix.file_descr -> string -> Unix.file_descr -> string -> at_flag list -> unit = "caml_extunix_linkat"
external symlinkat : string -> Unix.file_descr -> string -> unit = "caml_extunix_symlinkat"
END

HAVE UNAME

(** uname
    {b Author:} Sylvain Le Gall [sylvain\@le-gall.net]
  *)
module Uname = struct
type t =
    {
      sysname:    string;
      nodename:   string;
      release:    string;
      version:    string;
      machine:    string;
    }

let to_string t =
  String.concat " " [ t.sysname; t.nodename; t.release; t.version; t.machine ]
end

external uname : unit -> Uname.t = "caml_extunix_uname"

END

HAVE FADVISE

(** {2 posix_fadvise}

{b Author:} Sylvain Le Gall *)

(** access pattern *)
type advice =
  | POSIX_FADV_NORMAL     (** Indicates that the application has no advice to
                              give about its access pattern for the specified
                              data.  *)
  | POSIX_FADV_SEQUENTIAL (** The application expects to access the specified
                              data sequentially.  *)
  | POSIX_FADV_RANDOM     (** The specified data will be accessed in random
                              order.  *)
  | POSIX_FADV_NOREUSE    (** The specified data will be accessed only once.  *)
  | POSIX_FADV_WILLNEED   (** The specified data will be accessed in the near
                              future.  *) 
  | POSIX_FADV_DONTNEED   (** The specified data will not be accessed in the
                              near future.  *)

(** predeclare an access pattern for file data *)
external fadvise: Unix.file_descr -> int -> int -> advice -> unit = "caml_extunix_fadvise"

END

HAVE FALLOCATE

(** {2 posix_fallocate} *)
(** Allocate disk space for file

    {b Author:} Sylvain Le Gall
  *)

(** [fallocate fd off len] allocates disk space to ensure that subsequent writes
    between [off] and [off + len] in [fd] will not fail because of lack of disk 
    space. The file size is modified if [off + len] is bigger than the current size.
  *)
external fallocate: Unix.file_descr -> int -> int -> unit = "caml_extunix_fallocate"

END

HAVE PREAD
(** {2 pread}

    {b Author:} Goswin von Brederlow *)

(** [all_pread fd off buf ofs len] reads up to [len] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the string [buf] at offset [ofs]. The file offset is not changed.

    [all_pread] repeats the read operation until all characters have
    been read or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK or End-of-file but
    only ever returns 0 on End-of-file. Continues the read operation
    on EINTR. Raises an Unix.Unix_error exception in all other
    cases. *)
external unsafe_all_pread: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_all_pread"

let all_pread fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.all_pread"
  else unsafe_all_pread fd off buf ofs len

(** [single_pread fd off buf ifs len] reads up to [len] bytes from
    file descriptor [fd] at offset [off] (from the start of the file)
    into the string [buf] at offset [ofs]. The file offset is not
    changed.

    [single_pread] attempts to read only once. Returns the number of
    characters read or raises an Unix.Unix_error exception. Unlike the
    string variant of the same name there is no limit on the number of
    characters read. *)
external unsafe_single_pread: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_single_pread"

let single_pread fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.single_pread"
  else unsafe_single_pread fd off buf ofs len

(** [pread fd off buf ofs len] reads up to [len] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the string [buf] at offset [ofs]. The file offset is not changed.

    [pread] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Continues
    the read operation on EINTR. Returns the number of characters
    written in all other cases. *)
external unsafe_pread: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_pread"

let pread fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.pread"
  else unsafe_pread fd off buf ofs len

(** [intr_pread fd off buf ofs len] reads up to [len] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the string [buf] at offset [ofs]. The file offset is not changed.

    [intr_pread] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external unsafe_intr_pread: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_intr_pread"

let intr_pread fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.intr_pread"
  else unsafe_intr_pread fd off buf ofs len
END

HAVE PWRITE
(** {2 pwrite}

    {b Author:} Goswin von Brederlow *)

(** [all_pwrite fd off buf ofs len] writes up to [len] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the string [buf] at offset [ofs]. The file offset is not changed.

    [all_pwrite] repeats the write operation until all characters have
    been written or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK but never 0. Continues
    the write operation on EINTR. Raises an Unix.Unix_error exception
    in all other cases. *)
external unsafe_all_pwrite: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_all_pwrite"

let all_pwrite fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.all_pwrite"
  else unsafe_all_pwrite fd off buf ofs len

(** [single_pwrite fd off buf ofs len] writes up to [len] bytes from
    file descriptor [fd] at offset [off] (from the start of the file)
    into the string [buf] at offset [ofs]. The file offset is not
    changed.

    [single_pwrite] attempts to write only once. Returns the number of
    characters written or raises an Unix.Unix_error exception. Unlike
    the string variant of the same name there is no limit on the
    number of characters written. *)
external unsafe_single_pwrite: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_single_pwrite"

let single_pwrite fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.single_pwrite"
  else unsafe_single_pwrite fd off buf ofs len

(** [pwrite fd off buf ofs len] writes up to [len] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the string [buf] at offset [ofs]. The file offset is not changed.

    [pwrite] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Continues
    the write operation on EINTR. Returns the number of characters
    written in all other cases. *)
external unsafe_pwrite: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_pwrite"

let pwrite fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.pwrite"
  else unsafe_pwrite fd off buf ofs len

(** [intr_pwrite fd off buf ofs len] writes up to [len] bytes from
    file descriptor [fd] at offset [off] (from the start of the file)
    into the string [buf] at offset [ofs]. The file offset is not
    changed.

    [intr_pwrite] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external unsafe_intr_pwrite: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_intr_pwrite"

let intr_pwrite fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.intr_pwrite"
  else unsafe_intr_pwrite fd off buf ofs len
END

HAVE READ
(** {2 read}

    {b Author:} Goswin von Brederlow *)

(** [all_read fd buf ofs len] reads up to [len] bytes from file
    descriptor [fd] into the string [buf] at offset [ofs].

    [all_read] repeats the read operation until all characters have
    been read or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK or End-of-file but
    only ever returns 0 on End-of-file. Continues the read operation
    on EINTR. Raises an Unix.Unix_error exception in all other
    cases. *)
external unsafe_all_read: Unix.file_descr -> string -> int -> int -> int = "caml_extunix_all_read"

let all_read fd buf ofs len =
  if ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.all_read"
  else unsafe_all_read fd buf ofs len

(** [single_read fd buf ifs len] reads up to [len] bytes from file
    descriptor [fd] into the string [buf] at offset [ofs].

    [single_read] attempts to read only once. Returns the number of
    characters read or raises an Unix.Unix_error exception. Unlike the
    string variant of the same name there is no limit on the number of
    characters read. *)
external unsafe_single_read: Unix.file_descr -> string -> int -> int -> int = "caml_extunix_single_read"

let single_read fd buf ofs len =
  if ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.single_read"
  else unsafe_single_read fd buf ofs len

(** [read fd buf ofs len] reads up to [len] bytes from file descriptor
    [fd] into the string [buf] at offset [ofs].

    [read] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Continues
    the read operation on EINTR. Returns the number of characters
    written in all other cases. *)
external unsafe_read: Unix.file_descr -> string -> int -> int -> int = "caml_extunix_read"

let read fd buf ofs len =
  if ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.pread"
  else unsafe_read fd buf ofs len

(** [intr_read fd buf ofs len] reads up to [len] bytes from file
    descriptor [fd] into the string [buf] at offset [ofs].

    [intr_read] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external unsafe_intr_read: Unix.file_descr -> string -> int -> int -> int = "caml_extunix_intr_read"

let intr_read fd buf ofs len =
  if ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.intr_read"
  else unsafe_intr_read fd buf ofs len
END

HAVE WRITE
(** {2 write}

    {b Author:} Goswin von Brederlow *)

(** [all_write fd buf ofs len] writes up to [len] bytes from file
    descriptor [fd] into the string [buf] at offset [ofs].

    [all_write] repeats the write operation until all characters have
    been written or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK but never 0. Continues
    the write operation on EINTR. Raises an Unix.Unix_error exception
    in all other cases. *)
external unsafe_all_write: Unix.file_descr -> string -> int -> int -> int = "caml_extunix_all_write"

let all_write fd buf ofs len =
  if ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.all_write"
  else unsafe_all_write fd buf ofs len

(** [single_write fd buf ofs len] writes up to [len] bytes from file
    descriptor [fd] into the string [buf] at offset [ofs].

    [single_write] attempts to write only once. Returns the number of
    characters written or raises an Unix.Unix_error exception. Unlike
    the string variant of the same name there is no limit on the
    number of characters written. *)
external unsafe_single_write: Unix.file_descr -> string -> int -> int -> int = "caml_extunix_single_write"

let single_write fd buf ofs len =
  if ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.single_write"
  else unsafe_single_write fd buf ofs len

(** [write fd buf ofs len] writes up to [len] bytes from file
    descriptor [fd] into the string [buf] at offset [ofs].

    [write] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Continues
    the write operation on EINTR. Returns the number of characters
    written in all other cases. *)
external unsafe_write: Unix.file_descr -> string -> int -> int -> int = "caml_extunix_write"

let write fd buf ofs len =
  if ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.pwrite"
  else unsafe_write fd buf ofs len

(** [intr_write fd buf ofs len] writes up to [len] bytes from file
    descriptor [fd] into the string [buf] at offset [ofs].

    [intr_write] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external unsafe_intr_write: Unix.file_descr -> string -> int -> int -> int = "caml_extunix_intr_write"

let intr_write fd buf ofs len =
  if ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.intr_write"
  else unsafe_intr_write fd buf ofs len
END

(** {2 File operations on large files} *)

(** File operations on large files. This sub-module provides 64-bit
    variants of the functions ExtUnix.fadvise (for predeclaring an
    access pattern for file data), ExtUnix.fallocate (for allocating
    disk space for a file), ExtUnix.all_pread, ExtUnix.single_pread,
    ExtUnix.pread, ExtUnix.intr_pread, ExtUnix.all_pwrite,
    ExtUnix.single_pwrite, ExtUnix.pwrite and ExtUnix.intr_pwrite
    (for reading from or writing to a file descriptor at a given
    offset). These alternate functions represent positions and sizes
    by 64-bit integers (type int64) instead of regular integers
    (type int), thus allowing operating on files whose sizes are
    greater than max_int. *)
module LargeFile =
struct

  HAVE FADVISE
  external fadvise: Unix.file_descr -> int64 -> int64 -> advice -> unit = "caml_extunix_fadvise64"
  END

  HAVE FALLOCATE
  external fallocate: Unix.file_descr -> int64 -> int64 -> unit = "caml_extunix_fallocate64"
  END

  HAVE PREAD
  external unsafe_all_pread: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_all_pread64"

  let all_pread fd off buf ofs len =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.all_pread"
    else unsafe_all_pread fd off buf ofs len

  external unsafe_single_pread: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_single_pread64"

  let single_pread fd off buf ofs len =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.single_pread"
    else unsafe_single_pread fd off buf ofs len

  external unsafe_pread: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_pread64"

  let pread fd off buf ofs len =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.pread"
    else unsafe_pread fd off buf ofs len

  external unsafe_intr_pread: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_intr_pread64"

  let intr_pread fd off buf ofs len =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.intr_pread"
    else unsafe_intr_pread fd off buf ofs len
  END

  HAVE PWRITE
  external unsafe_all_pwrite: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_all_pwrite64"

  let all_pwrite fd off buf ofs len =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.all_pwrite"
    else unsafe_all_pwrite fd off buf ofs len

  external unsafe_single_pwrite: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_single_pwrite64"

  let single_pwrite fd off buf ofs len =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.single_pwrite"
    else unsafe_single_pwrite fd off buf ofs len

  external unsafe_pwrite: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_pwrite64"

  let pwrite fd off buf ofs len =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.pwrite"
    else unsafe_pwrite fd off buf ofs len

  external unsafe_intr_pwrite: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_intr_pwrite64"

  let intr_pwrite fd off buf ofs len =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.intr_pwrite"
    else unsafe_intr_pwrite fd off buf ofs len
  END

  (** {2 Bigarray variants} *)

  (** *)
  module BA = struct

  HAVE PREAD
  external unsafe_all_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_all_pread64"

  let all_pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.all_pread"
    else unsafe_all_pread fd off buf

  external unsafe_single_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_single_pread64"

  let single_pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.single_pread"
    else unsafe_single_pread fd off buf

  external unsafe_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_pread64"

  let pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.pread"
    else unsafe_pread fd off buf

  external unsafe_intr_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_intr_pread64"

  let intr_pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.intr_pread"
    else unsafe_intr_pread fd off buf
  END

  HAVE PWRITE
  external unsafe_all_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_all_pwrite64"

  let all_pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.all_pwrite"
    else unsafe_all_pwrite fd off buf

  external unsafe_single_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_single_pwrite64"

  let single_pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.single_pwrite"
    else unsafe_single_pwrite fd off buf

  external unsafe_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_pwrite64"

  let pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.pwrite"
    else unsafe_pwrite fd off buf

  external unsafe_intr_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_intr_pwrite64"

  let intr_pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.intr_pwrite"
    else unsafe_intr_pwrite fd off buf
  END

  end (* module BA *)

end (* module LargeFile *)

(** {2 ioctl} *)

(** Control the underlying device parameters of special files *)
module Ioctl = struct

HAVE SIOCGIFCONF
(** [siocgifconf sock], where [sock] is any socket, e.g. [socket PF_INET SOCK_DGRAM 0]
  @return the list of interfaces and corresponfing addresses *)
external siocgifconf : sock:Unix.file_descr -> (string * string) list = "caml_extunix_ioctl_siocgifconf"
END

HAVE TTY_IOCTL

(** Enable RTS/CTS (hardware) flow control. See CRTSCTS in tcsetattr(3). 
    {b FIXME this is likely to disappear when separate interface for [tcsetattr] and [tcgetattr] gets implemented} *)
external crtscts : Unix.file_descr -> int = "caml_extunix_crtscts"

(** Get the status of modem bits. See TIOCMGET in tty_ioctl(4). *)
external tiocmget : Unix.file_descr -> int = "caml_extunix_ioctl_TIOCMGET"

(** Set the status of modem bits. See TIOCMSET in tty_ioctl(4). *)
external tiocmset : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMSET"

(** Clear the indicated modem bits. See TIOCMBIC in tty_ioctl(4). *)
external tiocmbic : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIC"

(** Set the indicated modem bits. See TIOCMBIS in tty_ioctl(4). *)
external tiocmbis : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIS"

END

end (* module Ioctl *)

(** {2 Miscellaneous} *)

HAVE TTYNAME
(** @return name of terminal *)
external ttyname : Unix.file_descr -> string = "caml_extunix_ttyname"
END

HAVE CTERMID
(** Get controlling terminal name *)
external ctermid : unit -> string = "caml_extunix_ctermid"
END

HAVE PGID

(** [setpgid pid pgid] sets the process group of the process specified by [pid] to [pgid].
    If [pid] is zero, then the process ID of the calling process is used. If
    [pgid] is zero, then the PGID of the process specified by [pid] is made the same as its process ID. *)
external setpgid : int -> int -> unit = "caml_extunix_setpgid"

(** [getpgid pid] returns the PGID of the process specified by [pid].
    If [pid] is zero, the process ID of the calling process is used. *)
external getpgid : int -> int = "caml_extunix_getpgid"

(** [getsid pid] returns the session ID of the process specified by [pid].
    If [pid] is zero, the process ID of the calling process is used. *)
external getsid : int -> int = "caml_extunix_getsid"

END

HAVE SETREUID

(** [setreuid ruid euid] sets real and effective user IDs of the calling process.
    Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged. 
    @see "setreuid(2)" manual *)
external setreuid : int -> int -> unit = "caml_extunix_setreuid"

(** [setregid rgid egid] sets real and effective group IDs of the calling process.
    Supplying a value of -1 for either the real or effective group ID forces the system to leave that ID unchanged. 
    @see "setregid(2)" manual *)
external setregid : int -> int -> unit = "caml_extunix_setregid"

END

HAVE SETRESUID

(** [setresuid ruid euid suid] sets real, effective and saved user IDs of the calling process.
    Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged. 
    @see "setresuid(2)" manual *)
external setresuid: int -> int -> int -> unit = "caml_extunix_setresuid"

(** [setresgid rgid egid sgid] sets real, effective and saved group IDs of the calling process.
    Supplying a value of -1 for either the real or effective group ID forces the system to leave that ID unchanged. 
    @see "setresgid(2)" manual *)
external setresgid: int -> int -> int -> unit = "caml_extunix_setresgid"

END

HAVE REALPATH
(** [realpath path]
    @return the canonicalized absolute pathname of [path]
    @see "realpath(2)" manual *)
external realpath : string -> string = "caml_extunix_realpath"
END

HAVE FCNTL
(** @return whether file desctiptor is open *)
external is_open_descr : Unix.file_descr -> bool = "caml_extunix_is_open_descr"
END

HAVE TCPGRP
external tcgetpgrp : Unix.file_descr -> int = "caml_extunix_tcgetpgrp"
external tcsetpgrp : Unix.file_descr -> int -> unit = "caml_extunix_tcsetpgrp"
END

(** @raise Not_available if OS does not represent file descriptors as numbers *)
let int_of_file_descr : Unix.file_descr -> int =
  if Obj.is_block (Obj.repr Unix.stdin) then
    fun _ -> raise (Not_available "int_of_file_descr")
  else
    Obj.magic

(** @raise Not_available if OS does not represent file descriptors as numbers *)
let file_descr_of_int : int -> Unix.file_descr =
  if Obj.is_block (Obj.repr Unix.stdin) then
    fun _ -> raise (Not_available "file_descr_of_int")
  else
    Obj.magic

(** Exit process without running any [at_exit] hooks (implemented in Pervasives) *)
external sys_exit : int -> 'a = "caml_sys_exit"

HAVE SIGNALFD

(** {2 signalfd} *)

(** OCaml bindings for signalfd(2) and related functions

    {b Author:} Kaustuv Chaudhuri <kaustuv.chaudhuri\@inria.fr>
*)

(******************************************************************************)
(* signalfd bindings                                                          *)
(*                                                                            *)
(* NO COPYRIGHT -- RELEASED INTO THE PUBLIC DOMAIN                            *)
(*                                                                            *)
(* Author: Kaustuv Chaudhuri <kaustuv.chaudhuri@inria.fr>                     *)
(******************************************************************************)

(** [signalfd ?fd sigs flags ()]
    If the first optional argument is omitted, then a new file descriptor is allocated.
    Otherwise, the given file descriptor is modified (in which case it
    must have been created with [signalfd] previously). When you are
    done with the fd, remember to {!Unix.close} it. Do not forget
    to block [sigs] with {!Unix.sigprocmask} to prevent signal handling
    according to default dispositions.
    @see "signalfd(2)" manual
    *)
external signalfd : ?fd:Unix.file_descr -> sigs:int list -> flags:int list -> unit -> Unix.file_descr ="caml_extunix_signalfd"

(** This type represents signal information that is read(2) from the
    signalfd. *)
type ssi

(** Blocking read(2) on a signalfd. Has undefined behaviour on
    non-signalfds. Every successful read consumes a pending signal. *)
external signalfd_read    : Unix.file_descr -> ssi = "caml_extunix_signalfd_read"

(** {6 Functions to query the signal information structure.} *)

(** Get the signal value. This form is compatible with the signal
    values defined in the standard {!Sys} module.

    See signalfd(2) for the details of the remaining functions. Most
    of these integers are actually unsigned. *)
external ssi_signo_sys    : ssi -> int   = "caml_extunix_ssi_signo_sys"

external ssi_signo        : ssi -> int32 = "caml_extunix_ssi_signo"
external ssi_errno        : ssi -> int32 = "caml_extunix_ssi_errno"
external ssi_code         : ssi -> int32 = "caml_extunix_ssi_code"
external ssi_pid          : ssi -> int32 = "caml_extunix_ssi_pid"
external ssi_uid          : ssi -> int32 = "caml_extunix_ssi_uid"
external ssi_fd           : ssi -> Unix.file_descr = "caml_extunix_ssi_fd"
external ssi_tid          : ssi -> int32 = "caml_extunix_ssi_tid"
external ssi_band         : ssi -> int32 = "caml_extunix_ssi_band"
external ssi_overrun      : ssi -> int32 = "caml_extunix_ssi_overrun"
external ssi_trapno       : ssi -> int32 = "caml_extunix_ssi_trapno"
external ssi_status       : ssi -> int32 = "caml_extunix_ssi_status"
external ssi_int          : ssi -> int32 = "caml_extunix_ssi_int"
external ssi_ptr          : ssi -> int64 = "caml_extunix_ssi_ptr"
external ssi_utime        : ssi -> int64 = "caml_extunix_ssi_utime"
external ssi_stime        : ssi -> int64 = "caml_extunix_ssi_stime"
external ssi_addr         : ssi -> int64 = "caml_extunix_ssi_addr"

END

HAVE RESOURCE

(** 
  {2 POSIX resource operations}

  {b Author:} Sylvain Le Gall <sylvain\@le-gall.net>
*)

(** priority target *)
type which_prio_t =
  | PRIO_PROCESS of int (** Priority for a process id *)
  | PRIO_PGRP of int    (** Priority for a process group id *)
  | PRIO_USER of int    (** Priority for a user id *)

type priority = int

type resource =
  | RLIMIT_CORE   (** Limit on size of core dump file. *)
  | RLIMIT_CPU    (** Limit on CPU time per process. *)
  | RLIMIT_DATA   (** Limit on data segment size. *)
  | RLIMIT_FSIZE  (** Limit on file size. *)
  | RLIMIT_NOFILE (** Limit on number of open files. *)
  | RLIMIT_STACK  (** Limit on stack size. *)
  | RLIMIT_AS     (** Limit on address space size. *)

(** get resource name *)
let string_of_resource = function
  | RLIMIT_CORE   -> "RLIMIT_CORE"
  | RLIMIT_CPU    -> "RLIMIT_CPU"
  | RLIMIT_DATA   -> "RLIMIT_DATA"
  | RLIMIT_FSIZE  -> "RLIMIT_FSIZE"
  | RLIMIT_NOFILE -> "RLIMIT_NOFILE"
  | RLIMIT_STACK  -> "RLIMIT_STACK"
  | RLIMIT_AS     -> "RLIMIT_AS"

(** Limits *)
module Rlimit = struct

  type t = int64 option (** [Some limit] is fixed limit, [None] is RLIM_INFINITY *)

  let string_of_bytes n =
    let sz, acc = List.fold_left (fun (sz, acc) e ->
      let q = Int64.div sz 1024L in
      let r = Int64.rem sz 1024L in
      let acc = if r <> 0L then Printf.sprintf "%Ld %s" r e :: acc else acc in
      (q, acc)) (n, []) ["B"; "KB"; "MB"; "GB"] 
    in
    let acc = if sz <> 0L then Printf.sprintf "%Ld TB" sz :: acc else acc in
    match acc with
    | [] -> "0 B"
    | _ -> String.concat " " acc

  let to_string ?r = function
  | None -> "infinity"
  | Some l ->
    match r with 
    | None -> Int64.to_string l
    | Some RLIMIT_CORE
    | Some RLIMIT_DATA 
    | Some RLIMIT_FSIZE
    | Some RLIMIT_STACK
    | Some RLIMIT_AS -> string_of_bytes l
    | Some RLIMIT_NOFILE -> Int64.to_string l
    | Some RLIMIT_CPU -> Printf.sprintf "%Ld s" l

  let compare l1 l2 =
    match l1, l2 with
    | Some l1, Some l2 -> Int64.compare l1 l2
    | None, None -> 0
    | Some _, None -> -1
    | None, Some _ -> 1

  let eq l1 l2 = compare l1 l2 = 0
  let gt l1 l2 = compare l1 l2 > 0
  let ge l1 l2 = compare l1 l2 >= 0
  let lt l1 l2 = compare l1 l2 < 0
  let le l1 l2 = compare l1 l2 <= 0

end (* Rlimit *)

(** Get nice value *)
external getpriority : which_prio_t -> priority = "caml_extunix_getpriority" 

(** Set nice value *)
external setpriority : which_prio_t -> priority -> unit = "caml_extunix_setpriority"

(** Get maximum resource consumption. @return [(soft,hard)] limits *)
external getrlimit : resource -> Rlimit.t * Rlimit.t = "caml_extunix_getrlimit"

(** Set maximum resource consumption *)
external setrlimit : resource -> soft:Rlimit.t -> hard:Rlimit.t -> unit = "caml_extunix_setrlimit"

(* let unlimit_soft r = let (_,hard) = getrlimit r in setrlimit r ~soft:hard ~hard *)

(** [getrusage] is not implemented because the only meaningful information it
    provides are [ru_utime] and [ru_stime] which can be accessed through 
    [Unix.times].
  *)

END

(** {2 Memory management} *)

HAVE MLOCKALL

(** mlockall flag *)
type mlockall_flag = MCL_CURRENT | MCL_FUTURE

(** Lock all pages mapped into the address space of the calling process. *)
external mlockall : mlockall_flag list -> unit = "caml_extunix_mlockall"

(** Unlock all pages mapped into the address space of the calling process. *)
external munlockall : unit -> unit = "caml_extunix_munlockall"

END

HAVE MEMALIGN

(** [memalign alignment size] creates a {!Bigarray.Array1.t} of [size] bytes,
    which data is aligned to [alignment] (must be a power of 2)

    {b Author:} Goswin von Brederlow
*)
external memalign: int -> int -> buffer = "caml_extunix_memalign"

END

(** {2 Time conversion} *)

HAVE STRTIME

(** This function is the converse of the {!strftime} function.
  [strptime fmt data] convert a string containing time information [data]
  into a [tm] struct according to the format specified by [fmt]. *)
external strptime: string -> string -> Unix.tm = "caml_extunix_strptime"

(** Return the ascii representation of a given [tm] argument. The
  ascii time is returned in the form of a string like 
  'Wed Jun 30, 21:21:21 2005\n' *)
external asctime: Unix.tm -> string = "caml_extunix_asctime"

(** This functions is the converse of the {!strptime} function.
  [strftime fmt data] convert a a [tm] structure [data] into a string
  according to the format specified by [fmt]. *)
external strftime: string -> Unix.tm -> string = "caml_extunix_strftime"

(** [tzname isdst] 
  @param isdst specifies whether daylight saving is in effect
  @return abbreviated name of the current timezone
*)
external tzname : bool -> string = "caml_extunix_tzname"

END

HAVE TIMEGM

(** Inverse of [Unix.gmtime] *)
external timegm : Unix.tm -> float = "caml_extunix_timegm"

END

HAVE PTS

(** 
  {2 Pseudo terminal management}

  {b Author:} Niki Yoshiuchi <aplusbi\@gmail.com> 
*)

(** This function opens a pseudo-terminal device. *)
external posix_openpt : Unix.open_flag list -> 
  Unix.file_descr = "caml_extunix_posix_openpt"

(** This function grants access to the slave pseudo-terminal. *)
external grantpt: Unix.file_descr -> unit = "caml_extunix_grantpt"

(** This function unlock a pseudo-terminal master/slave pair. *)
external unlockpt: Unix.file_descr -> unit = "caml_extunix_unlockpt"

(** This function get the name of the slave pseudo-terminal. *)
external ptsname: Unix.file_descr -> string = "caml_extunix_ptsname"

END

(** {2 Application self-debugging and diagnostics} *)

HAVE EXECINFO

(** @return a backtrace for the calling program *)
external backtrace : unit -> string array = "caml_extunix_backtrace"

END

HAVE MALLOC_STATS

(** Print brief heap summary statistics on stderr *)
external malloc_stats : unit -> unit = "caml_extunix_malloc_stats"

END

HAVE MALLOC_INFO

(** @return the information about state of allocator *)
external malloc_info : unit -> string = "caml_extunix_malloc_info"

END

HAVE PTRACE

external ptrace_traceme : unit -> unit = "caml_extunix_ptrace_traceme"
external ptrace_peekdata : int -> nativeint -> nativeint = "caml_extunix_ptrace_peekdata"
external ptrace_peektext : int -> nativeint -> nativeint = "caml_extunix_ptrace_peektext"

type ptrace_request =
  | PTRACE_ATTACH
  | PTRACE_DETACH

external ptrace : int -> ptrace_request -> unit = "caml_extunix_ptrace"

END

(** {2 Environment manipulation} *)

HAVE SETENV

(** [setenv name value overwrite] adds the variable [name] to the environment with the value [value], if [name]
does not already exist or [overwrite] is true *)
external setenv : string -> string -> bool -> unit = "caml_extunix_setenv"

(** [unsetenv name] removes variable [name] from the environment. If [name] does not exist in the environment, then the function
succeeds, and the environment is unchanged. *)
external unsetenv : string -> unit = "caml_extunix_unsetenv"

END

HAVE CLEARENV

(** Clear the environment of all name-value pairs *)
external clearenv : unit -> unit = "caml_extunix_clearenv"

END

(** {2 Temporary directories} *)

HAVE MKDTEMP

(** [mkdtemp template] creates a unique temporary directory (with permissions 0700).
  Last six characters of [template] must be "XXXXXX". *)
external mkdtemp : string -> string = "caml_extunix_mkdtemp"

END

HAVE MKSTEMPS

(** internal use only *)
external internal_mkstemps : string -> int -> Unix.file_descr = "caml_extunix_internal_mkstemps"

(** [mkstemp ?(suffix="") prefix] generates a unique temporary
    filename in the form [prefix]XXXXXX[suffix], creates and opens the
    file, and returns an open file descriptor and name for the
    file. *)
let mkstemp ?(suffix="") prefix =
  let prefixlen = String.length prefix in
  let suffixlen = String.length suffix in
  let len = prefixlen + 6 + suffixlen in
  let s = String.create len
  in
  String.blit prefix 0 s 0 prefixlen;
  String.blit "XXXXXX" 0 s prefixlen 6;
  String.blit suffix 0 s (prefixlen + 6) suffixlen;
  let fd = internal_mkstemps s suffixlen
  in
  (fd, s)
END

HAVE MKOSTEMPS

(** internal use only *)
external internal_mkostemps : string -> int -> Unix.open_flag list -> Unix.file_descr = "caml_extunix_internal_mkostemps"

(** [mkostemp ?(suffix="") ?(flags=[]) prefix] generates a unique temporary
    filename in the form [prefix]XXXXXX[suffix], creates and opens the
    file with [flags], and returns an open file descriptor and name
    for the file. *)
let mkostemp ?(suffix="") ?(flags=[]) prefix =
  let prefixlen = String.length prefix in
  let suffixlen = String.length suffix in
  let len = prefixlen + 6 + suffixlen in
  let s = String.create len
  in
  String.blit prefix 0 s 0 prefixlen;
  String.blit "XXXXXX" 0 s prefixlen 6;
  String.blit suffix 0 s (prefixlen + 6) suffixlen;
  let fd = internal_mkostemps s suffixlen flags
  in
  (fd, s)

END

(** {2 Byte order conversion} *)

(** {2 big endian functions}

    {b Author:} Goswin von Brederlow *)
module BigEndian = struct

HAVE ENDIAN
  (** Conversion functions from host to big endian byte order and back *)

  (** Conversion of 16bit integers *)
  (** [uint16_from_host u16] converts an unsigned 16bit integer from host to
      big endian byte order *)
  external uint16_from_host : int -> int = "caml_extunix_htobe16"

  (** [int16_from_host i16] converts a signed 16bit integer from host to
      big endian byte order *)
  external int16_from_host : int -> int = "caml_extunix_htobe16_signed"

  (** [uint16_to_host u16] converts an unsigned 16bit integer from big
      endian to host byte order *)
  external uint16_to_host : int -> int = "caml_extunix_be16toh"

  (** [int16_to_host i16] converts a signed 16bit integer from big
      endian to host byte order *)
  external int16_to_host : int -> int = "caml_extunix_be16toh_signed"

  (** Conversion of 31bit integeres
      On 64bit platforms this actualy converts 32bit integers without
      the need to allocate a new int32. On 32bit platforms it produces
      garbage. For use on 64bit platforms only! *)
  (** [uint31_from_host u31] converts an unsigned 31bit integer from
      host to big endian byte order *)
  external uint31_from_host : int -> int = "caml_extunix_htobe31"

  (** [int31_from_host i31] converts a signed 31bit integer from host to
      big endian byte order *)
  external int31_from_host : int -> int = "caml_extunix_htobe31_signed"

  (** [uint31_to_host u31] converts an unsigned 31bit integer from big
      endian to host byte order *)
  external uint31_to_host : int -> int = "caml_extunix_be31toh"

  (** [int31_to_host i31] converts a signed 31bit integer from big
      endian to host byte order *)
  external int31_to_host : int -> int = "caml_extunix_be31toh_signed"

  (** Conversion of 32bit integers *)
  (** [int32_from_host int32] converts a 32bit integer from host to big
      endian byte order *)
  external int32_from_host : int32 -> int32 = "caml_extunix_htobe32"

  (** [int32_to_host int32] converts a 32bit integer from big endian to
      host byte order *)
  external int32_to_host : int32 -> int32 = "caml_extunix_be32toh"

  (** Conversion of 64bit integers *)
  (** [int64_from_host int64] converts a 64bit integer from host to big
      endian byte order *)
  external int64_from_host : int64 -> int64 = "caml_extunix_htobe64"

  (** [int64_to_host int64] converts a 64bit integer from big endian to
      host byte order *)
  external int64_to_host : int64 -> int64 = "caml_extunix_be64toh"

  (** [unsafe_get_X str off] extract integer of type [X] from string
      [str] starting at offset [off]. Unsigned types are 0 extended
      and signed types are sign extended to fill the ocaml type.
      Bounds checking is not performed. Use with caution and only when
      the program logic guarantees that the access is within bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : string -> int -> int = "caml_extunix_get_u8"
  external unsafe_get_int8   : string -> int -> int = "caml_extunix_get_s8"
  external unsafe_get_uint16 : string -> int -> int = "caml_extunix_get_bu16"
  external unsafe_get_int16  : string -> int -> int = "caml_extunix_get_bs16"
  external unsafe_get_uint31 : string -> int -> int = "caml_extunix_get_bu31"
  external unsafe_get_int31  : string -> int -> int = "caml_extunix_get_bs31"
  external unsafe_get_int32  : string -> int -> int32 = "caml_extunix_get_bs32"
  external unsafe_get_int64  : string -> int -> int64 = "caml_extunix_get_bs64"

  (** [get_X str off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 str off

  let get_int8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 str off

  let get_uint16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 str off

  let get_int16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 str off

  let get_uint31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 str off

  let get_int31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 str off

  let get_int32 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 str off

  let get_int64 str off =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 str off

  (** [unsafe_set_X str off v] stores the integer [v] as type [X] in
      string [str] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_int8   : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_uint16 : string -> int -> int -> unit = "caml_extunix_set_b16"
  external unsafe_set_int16  : string -> int -> int -> unit = "caml_extunix_set_b16"
  external unsafe_set_uint31 : string -> int -> int -> unit = "caml_extunix_set_b31"
  external unsafe_set_int31  : string -> int -> int -> unit = "caml_extunix_set_b31"
  external unsafe_set_int32  : string -> int -> int32 -> unit = "caml_extunix_set_b32"
  external unsafe_set_int64  : string -> int -> int64 -> unit = "caml_extunix_set_b64"

  (** [set_X str off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 str off v

  let set_int8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 str off v

  let set_uint16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 str off v

  let set_int16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 str off v

  let set_uint31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 str off v

  let set_int31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 str off v

  let set_int32 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 str off v

  let set_int64 str off v =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 str off v

END

end

(** {2 little endian functions}

    {b Author:} Goswin von Brederlow *)
module LittleEndian = struct

HAVE ENDIAN

  (** Conversion functions from host to little endian byte order and back *)

  (** Conversion of 16bit integers *)
  (** [uint16_from_host u16] converts an unsigned 16bit integer from host to
      little endian byte order *)
  external uint16_from_host : int -> int = "caml_extunix_htole16"

  (** [int16_from_host i16] converts a signed 16bit integer from host to
      little endian byte order *)
  external int16_from_host : int -> int = "caml_extunix_htole16_signed"

  (** [uint16_to_host u16] converts an unsigned 16bit integer from little
      endian to host byte order *)
  external uint16_to_host : int -> int = "caml_extunix_le16toh"

  (** [int16_to_host i16] converts a signed 16bit integer from little
      endian to host byte order *)
  external int16_to_host : int -> int = "caml_extunix_le16toh_signed"

  (** Conversion of 31bit integeres
      On 64bit platforms this actualy converts 32bit integers without
      the need to allocate a new int32. On 32bit platforms it produces
      garbage. For use on 64bit platforms only! *)
  (** [uint31_from_host u31] converts an unsigned 31bit integer from
      host to little endian byte order *)
  external uint31_from_host : int -> int = "caml_extunix_htole31"

  (** [int31_from_host i31] converts a signed 31bit integer from host to
      little endian byte order *)
  external int31_from_host : int -> int = "caml_extunix_htole31_signed"

  (** [uint31_to_host u31] converts an unsigned 31bit integer from little
      endian to host byte order *)
  external uint31_to_host : int -> int = "caml_extunix_le31toh"

  (** [int31_to_host i31] converts a signed 31bit integer from little
      endian to host byte order *)
  external int31_to_host : int -> int = "caml_extunix_le31toh_signed"

  (** Conversion of 32bit integers *)
  (** [int32_from_host int32] converts a 32bit integer from host to little
      endian byte order *)
  external int32_from_host : int32 -> int32 = "caml_extunix_htole32"

  (** [int32_to_host int32] converts a 32bit integer from little endian to
      host byte order *)
  external int32_to_host : int32 -> int32 = "caml_extunix_le32toh"

  (** Conversion of 64bit integers *)
  (** [int64_from_host int64] converts a 64bit integer from host to little
      endian byte order *)
  external int64_from_host : int64 -> int64 = "caml_extunix_htole64"

  (** [int64_to_host int64] converts a 64bit integer from little endian to
      host byte order *)
  external int64_to_host : int64 -> int64 = "caml_extunix_le64toh"
  
  (** [unsafe_get_X str off] extract integer of type [X] from string
      [str] starting at offset [off]. Unsigned types are 0 extended
      and signed types are sign extended to fill the ocaml type.
      Bounds checking is not performed. Use with caution and only when
      the program logic guarantees that the access is within bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : string -> int -> int = "caml_extunix_get_u8"
  external unsafe_get_int8   : string -> int -> int = "caml_extunix_get_s8"
  external unsafe_get_uint16 : string -> int -> int = "caml_extunix_get_lu16"
  external unsafe_get_int16  : string -> int -> int = "caml_extunix_get_ls16"
  external unsafe_get_uint31 : string -> int -> int = "caml_extunix_get_lu31"
  external unsafe_get_int31  : string -> int -> int = "caml_extunix_get_ls31"
  external unsafe_get_int32  : string -> int -> int32 = "caml_extunix_get_ls32"
  external unsafe_get_int64  : string -> int -> int64 = "caml_extunix_get_ls64"

  (** [get_X str off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 str off

  let get_int8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 str off

  let get_uint16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 str off

  let get_int16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 str off

  let get_uint31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 str off

  let get_int31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 str off

  let get_int32 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 str off

  let get_int64 str off =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 str off

  (** [unsafe_set_X str off v] stores the integer [v] as type [X] in
      string [str] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_int8   : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_uint16 : string -> int -> int -> unit = "caml_extunix_set_l16"
  external unsafe_set_int16  : string -> int -> int -> unit = "caml_extunix_set_l16"
  external unsafe_set_uint31 : string -> int -> int -> unit = "caml_extunix_set_l31"
  external unsafe_set_int31  : string -> int -> int -> unit = "caml_extunix_set_l31"
  external unsafe_set_int32  : string -> int -> int32 -> unit = "caml_extunix_set_l32"
  external unsafe_set_int64  : string -> int -> int64 -> unit = "caml_extunix_set_l64"

  (** [set_X str off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 str off v

  let set_int8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 str off v

  let set_uint16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 str off v

  let set_int16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 str off v

  let set_uint31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 str off v

  let set_int31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 str off v

  let set_int32 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 str off v

  let set_int64 str off v =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 str off v

END

end

(** {2 host endian functions}

    {b Author:} Goswin von Brederlow *)
module HostEndian = struct

  (** [unsafe_get_X str off] extract integer of type [X] from string
      [str] starting at offset [off]. Unsigned types are 0 extended
      and signed types are sign extended to fill the ocaml type.
      Bounds checking is not performed. Use with caution and only when
      the program logic guarantees that the access is within bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : string -> int -> int = "caml_extunix_get_u8"
  external unsafe_get_int8   : string -> int -> int = "caml_extunix_get_s8"
  external unsafe_get_uint16 : string -> int -> int = "caml_extunix_get_hu16"
  external unsafe_get_int16  : string -> int -> int = "caml_extunix_get_hs16"
  external unsafe_get_uint31 : string -> int -> int = "caml_extunix_get_hu31"
  external unsafe_get_int31  : string -> int -> int = "caml_extunix_get_hs31"
  external unsafe_get_int32  : string -> int -> int32 = "caml_extunix_get_hs32"
  external unsafe_get_int64  : string -> int -> int64 = "caml_extunix_get_hs64"

  (** [get_X str off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 str off

  let get_int8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 str off

  let get_uint16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 str off

  let get_int16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 str off

  let get_uint31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 str off

  let get_int31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 str off

  let get_int32 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 str off

  let get_int64 str off =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 str off

  (** [unsafe_set_X str off v] stores the integer [v] as type [X] in
      string [str] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_int8   : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_uint16 : string -> int -> int -> unit = "caml_extunix_set_h16"
  external unsafe_set_int16  : string -> int -> int -> unit = "caml_extunix_set_h16"
  external unsafe_set_uint31 : string -> int -> int -> unit = "caml_extunix_set_h31"
  external unsafe_set_int31  : string -> int -> int -> unit = "caml_extunix_set_h31"
  external unsafe_set_int32  : string -> int -> int32 -> unit = "caml_extunix_set_h32"
  external unsafe_set_int64  : string -> int -> int64 -> unit = "caml_extunix_set_h64"

  (** [set_X str off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 str off v

  let set_int8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 str off v

  let set_uint16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 str off v

  let set_int16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 str off v

  let set_uint31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 str off v

  let set_int31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 str off v

  let set_int32 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 str off v

  let set_int64 str off v =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 str off v

end

HAVE READ_CREDENTIALS

(** {2 read_credentials }

      {b Author:} Andre Nathan *)

(** Reads sender credentials from a file descriptor, returning a 3-element
    tuple containing the sender process' PID, UID and GID. *)
external read_credentials : Unix.file_descr -> int * int * int = "caml_extunix_read_credentials"

END

HAVE FEXECVE

(** {2 fexecve }

    {b Author:} Andre Nathan *)

(** [fexecve fd args env] executes the program in file represented by
    file descriptor [fd] with arguments [args] and environment
    variables given by [env]. As with the [execv*] functions, on
    success [fexecve] never returns; the current process is replaced
    by the new one.
*)
external fexecve: Unix.file_descr -> string array -> string array -> 'a = "caml_extunix_fexecve"

  END

HAVE SENDMSG

(** {2 sendmsg / recvmsg }

    {b Author:} Andre Nathan *)

(** Send a message and optionally a file descriptor through a socket. Passing
    file descriptors requires UNIX domain sockets. *)
external sendmsg: Unix.file_descr -> ?sendfd:Unix.file_descr -> string -> unit = "caml_extunix_sendmsg"

(** Recieve a message and possibly a file descriptor from a socket.  *)
external recvmsg_fd: Unix.file_descr -> (Unix.file_descr option) * string = "caml_extunix_recvmsg"

(** Send a file descriptor through a UNIX domain socket. *)
let sendfd conn_fd fd_to_send =
  sendmsg conn_fd ~sendfd:fd_to_send ""

(** Receive a file descriptor sent through a UNIX domain socket. *)
let recvfd fd =
  match recvmsg_fd fd with
  | (Some recvfd, _) -> recvfd
  | _ -> raise (Unix.Unix_error (Unix.EINVAL, "recvfd", "no descriptor"))

(** Receive a message sent through a UNIX domain socket. Raises
    Recvfd(fd, msg) if a file descriptor is recieved. *)
exception Recvfd of Unix.file_descr * string
let recvmsg fd =
  match recvmsg_fd fd with
  | (None, msg) -> msg
  | (Some fd, msg) -> raise (Recvfd (fd, msg))

(** Receive a message sent through a UNIX domain socket. Closes and
    ignores file descriptors. *)
let recvmsg_nofd fd =
  match recvmsg_fd fd with
  | (Some fd, msg) -> Unix.close fd; msg
  | (None, msg) -> msg

END

(** {2 Bigarray variants} *)

(** *)
module BA = struct

HAVE PREAD
(** {2 pread}

    {b Author:} Goswin von Brederlow *)

(** [all_pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [all_pread] repeats the read operation until all characters have
    been read or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK or End-of-file but
    only ever returns 0 on End-of-file. Continues the read operation
    on EINTR. Raises an Unix.Unix_error exception in all other
    cases. *)
external unsafe_all_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_all_pread"

let all_pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.all_pread"
  else unsafe_all_pread fd off buf

(** [single_pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [single_pread] attempts to read only once. Returns the number of
    characters read or raises an Unix.Unix_error exception. Unlike the
    string variant of the same name there is no limit on the number of
    characters read. *)
external unsafe_single_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_single_pread"

let single_pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.single_pread"
  else unsafe_single_pread fd off buf

(** [pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [pread] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Continues
    the read operation on EINTR. Returns the number of characters
    written in all other cases. *)
external unsafe_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_pread"

let pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.pread"
  else unsafe_pread fd off buf

(** [intr_pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [intr_pread] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external unsafe_intr_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_intr_pread"

let intr_pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.intr_pread"
  else unsafe_intr_pread fd off buf
END

HAVE PWRITE
(** {2 pwrite}

    {b Author:} Goswin von Brederlow *)

(** [all_pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [all_pwrite] repeats the write operation until all characters have
    been written or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK but never 0. Continues
    the write operation on EINTR. Raises an Unix.Unix_error exception
    in all other cases. *)
external unsafe_all_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_all_pwrite"

let all_pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.all_pwrite"
  else unsafe_all_pwrite fd off buf

(** [single_pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [single_pwrite] attempts to write only once. Returns the number of
    characters written or raises an Unix.Unix_error exception. Unlike
    the string variant of the same name there is no limit on the
    number of characters written. *)
external unsafe_single_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_single_pwrite"

let single_pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.single_pwrite"
  else unsafe_single_pwrite fd off buf

(** [pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [pwrite] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Continues
    the write operation on EINTR. Returns the number of characters
    written in all other cases. *)
external unsafe_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_pwrite"

let pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.pwrite"
  else unsafe_pwrite fd off buf

(** [intr_pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [intr_pwrite] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external unsafe_intr_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_intr_pwrite"

let intr_pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.intr_pwrite"
  else unsafe_intr_pwrite fd off buf
END

HAVE READ
(** {2 read}

    {b Author:} Goswin von Brederlow *)

(** [all_read fd buf] reads up to [size of buf] bytes from file
    descriptor [fd] into the buffer [buf].

    [all_read] repeats the read operation until all characters have
    been read or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK or End-of-file but
    only ever returns 0 on End-of-file. Continues the read operation
    on EINTR. Raises an Unix.Unix_error exception in all other
    cases. *)
external all_read: Unix.file_descr -> buffer -> int = "caml_extunixba_all_read"

(** [single_read fd buf] reads up to [size of buf] bytes from file
    descriptor [fd] into the buffer [buf].

    [single_read] attempts to read only once. Returns the number of
    characters read or raises an Unix.Unix_error exception. Unlike the
    string variant of the same name there is no limit on the number of
    characters read. *)
external single_read: Unix.file_descr -> buffer -> int = "caml_extunixba_single_read"

(** [read fd buf] reads up to [size of buf] bytes from file descriptor
    [fd] into the buffer [buf].

    [read] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Continues
    the read operation on EINTR. Returns the number of characters
    written in all other cases. *)
external read: Unix.file_descr -> buffer -> int = "caml_extunixba_read"

(** [intr_read fd buf] reads up to [size of buf] bytes from file
    descriptor [fd] into the buffer [buf].

    [intr_read] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external intr_read: Unix.file_descr -> buffer -> int = "caml_extunixba_intr_read"
END

HAVE WRITE
(** {2 write}

    {b Author:} Goswin von Brederlow *)

(** [all_write fd buf] writes up to [size of buf] bytes from file
    descriptor [fd] into the buffer [buf].
    
    [all_write] repeats the write operation until all characters have
    been written or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK but never 0. Continues
    the write operation on EINTR. Raises an Unix.Unix_error exception
    in all other cases. *)
external all_write: Unix.file_descr -> buffer -> int = "caml_extunixba_all_write"

(** [single_write fd buf] writes up to [size of buf] bytes from file
    descriptor [fd] into the buffer [buf].

    [single_write] attempts to write only once. Returns the number of
    characters written or raises an Unix.Unix_error exception. Unlike
    the string variant of the same name there is no limit on the
    number of characters written. *)
external single_write: Unix.file_descr -> buffer -> int = "caml_extunixba_single_write"

(** [write fd buf] writes up to [size of buf] bytes from file
    descriptor [fd] into the buffer [buf].

    [write] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Continues
    the write operation on EINTR. Returns the number of characters
    written in all other cases. *)
external write: Unix.file_descr -> buffer -> int = "caml_extunixba_write"

(** [intr_write fd buf] writes up to [size of buf] bytes from file
    descriptor [fd] into the buffer [buf].

    [intr_write] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external intr_write: Unix.file_descr -> buffer -> int = "caml_extunixba_intr_write"
END

(** {2 Byte order conversion} *)

(** {2 big endian functions}

    {b Author:} Goswin von Brederlow *)
module BigEndian = struct

HAVE ENDIAN
  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_bu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_bs16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_bu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_bs31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_bs32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_bs64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_b16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_b16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_b31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_b31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_b32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_b64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

END

end

(** {2 little endian functions}

    {b Author:} Goswin von Brederlow *)
module LittleEndian = struct

HAVE ENDIAN

  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_lu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_ls16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_lu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_ls31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_ls32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_ls64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_l16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_l16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_l31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_l31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_l32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_l64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

END

end

(** {2 host endian functions}

    {b Author:} Goswin von Brederlow *)
module HostEndian = struct

  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_hu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_hs16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_hu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_hs31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_hs32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_hs64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_h16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_h16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_h31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_h31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_h32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_h64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

end

(** [unsafe_get_substr buf off len] extracts the substring from buffer
    [buf] starting at offset [off] and length [len]. Bounds checking
    is not performed. Use with caution and only when the program logic
    guarantees that the access is within bounds.*)
external unsafe_get_substr : buffer -> int -> int -> string = "caml_extunixba_get_substr"

(** [get_substr buf off len] same as [unsafe_get_substr] but with
    bounds checking. *)
let get_substr buf off len =
  if off < 0 || len < 0 || off > Bigarray.Array1.dim buf - len
  then raise (Invalid_argument "index out of bounds");
  unsafe_get_substr buf off len

(** [unsafe_set_substr buf off str] stores the string in buffer [buf]
    starting at offset [off]. Bounds checking is not performed. Use
    with caution and only when the program logic guarantees that the
    access is within bounds.*)
external unsafe_set_substr : buffer -> int -> string -> unit = "caml_extunixba_set_substr"

(** [set_substr buf off str] same as [unsafe_set_substr] but with
    bounds checking. *)
let set_substr buf off str =
  if off < 0 || off > Bigarray.Array1.dim buf - String.length str
  then raise (Invalid_argument "index out of bounds");
  unsafe_set_substr buf off str

end (* module BA *)

(* NB Should be after all 'external' definitions *)

(** {2 Meta} *)
(** [have name]
  @return indication whether function [name] is available
  - [Some true] if available
  - [Some false] if not available
  - [None] if not known

  e.g. [have "eventfd"]
*)
SHOW ME THE MONEY

